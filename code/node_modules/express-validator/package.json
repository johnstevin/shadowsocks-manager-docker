{
  "_args": [
    [
      {
        "raw": "express-validator@^3.1.1",
        "scope": null,
        "escapedName": "express-validator",
        "name": "express-validator",
        "rawSpec": "^3.1.1",
        "spec": ">=3.1.1 <4.0.0",
        "type": "range"
      },
      "/root/.nvm/versions/node/v7.10.0/lib/node_modules/shadowsocks-manager"
    ]
  ],
  "_from": "express-validator@>=3.1.1 <4.0.0",
  "_id": "express-validator@3.2.0",
  "_inCache": true,
  "_location": "/shadowsocks-manager/express-validator",
  "_nodeVersion": "6.10.2",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/express-validator-3.2.0.tgz_1492816347075_0.5195301142521203"
  },
  "_npmUser": {
    "name": "gustavohenke",
    "email": "guhenke@gmail.com"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "express-validator@^3.1.1",
    "scope": null,
    "escapedName": "express-validator",
    "name": "express-validator",
    "rawSpec": "^3.1.1",
    "spec": ">=3.1.1 <4.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/shadowsocks-manager"
  ],
  "_resolved": "https://registry.npmjs.org/express-validator/-/express-validator-3.2.0.tgz",
  "_shasum": "9537abeb0f66e439f9e30b4ed16c4c6c231318e2",
  "_shrinkwrap": null,
  "_spec": "express-validator@^3.1.1",
  "_where": "/root/.nvm/versions/node/v7.10.0/lib/node_modules/shadowsocks-manager",
  "author": {
    "name": "Christoph Tavan",
    "email": "dev@tavan.de"
  },
  "bugs": {
    "url": "https://github.com/ctavan/express-validator/issues"
  },
  "contributors": [
    {
      "name": "Chris O'Hara",
      "email": "cohara87@gmail.com"
    },
    {
      "name": "@orfaust"
    },
    {
      "name": "@zero21xxx"
    },
    {
      "name": "Roman Kalyakin",
      "email": "roman@kalyakin.com"
    },
    {
      "name": "Rusty Bailey",
      "email": "rustylbailey@gmail.com"
    },
    {
      "name": "Gustavo Henke",
      "email": "guhenke@gmail.com"
    },
    {
      "name": "Ayman Nedjmeddine",
      "email": "theycallmethedr@gmail.com"
    }
  ],
  "dependencies": {
    "@types/bluebird": "~3.0.36",
    "@types/express": "~4.0.34",
    "bluebird": "^3.4.0",
    "lodash": "^4.16.0",
    "validator": "~6.2.0"
  },
  "description": "Express middleware for the validator module.",
  "devDependencies": {
    "body-parser": "1.12.3",
    "chai": "2.3.0",
    "cookie-parser": "1.4.1",
    "coveralls": "2.11.14",
    "eslint": "^3.13.1",
    "express": "4.12.3",
    "mocha": "2.2.4",
    "nyc": "8.4.0",
    "supertest": "0.15.0",
    "typescript": "~2.0.10"
  },
  "directories": {},
  "dist": {
    "shasum": "9537abeb0f66e439f9e30b4ed16c4c6c231318e2",
    "tarball": "https://registry.npmjs.org/express-validator/-/express-validator-3.2.0.tgz"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "gitHead": "153de3209212ffae246377e1a4e046a5729b0b41",
  "homepage": "https://github.com/ctavan/express-validator",
  "keywords": [
    "express",
    "validator",
    "validation",
    "validate",
    "sanitize",
    "sanitization",
    "xss"
  ],
  "license": "MIT",
  "main": "./index.js",
  "maintainers": [
    {
      "name": "ctavan",
      "email": "dev@tavan.de"
    },
    {
      "name": "gustavohenke",
      "email": "guhenke@gmail.com"
    },
    {
      "name": "rustybailey",
      "email": "rustylbailey@gmail.com"
    }
  ],
  "name": "express-validator",
  "optionalDependencies": {},
  "readme": "# express-validator\n\n[![npm version](https://img.shields.io/npm/v/express-validator.svg)](https://www.npmjs.com/package/express-validator)\n[![Build Status](https://img.shields.io/travis/ctavan/express-validator.svg)](http://travis-ci.org/ctavan/express-validator)\n[![Dependency Status](https://img.shields.io/david/ctavan/express-validator.svg)](https://david-dm.org/ctavan/express-validator)\n[![Coverage Status](https://img.shields.io/coveralls/ctavan/express-validator.svg)](https://coveralls.io/github/ctavan/express-validator?branch=master)\n\nAn [express.js]( https://github.com/visionmedia/express ) middleware for\n[node-validator]( https://github.com/chriso/validator.js ).\n\n- [Installation](#installation)\n- [Usage](#usage)\n- [Middleware options](#middleware-options)\n- [Validation](#validation)\n- [Validation by schema](#validation-by-schema)\n- [Validation result](#validation-result)\n  + [Result API](#result-api)\n  + [Deprecated API](#deprecated-api)\n  + [String formatting for error messages](#string-formatting-for-error-messages)\n  + [Per-validation messages](#per-validation-messages)\n- [Optional input](#optional-input)\n- [Sanitizer](#sanitizer)\n- [Regex routes](#regex-routes)\n- [TypeScript](#typescript)\n- [Changelog](#changelog)\n- [License](#license)\n\n## Installation\n\n```\nnpm install express-validator\n```\n\n## Usage\n\n```javascript\nvar util = require('util'),\n    bodyParser = require('body-parser'),\n    express = require('express'),\n    expressValidator = require('express-validator'),\n    app = express();\n\napp.use(bodyParser.json());\napp.use(expressValidator([options])); // this line must be immediately after any of the bodyParser middlewares!\n\napp.post('/:urlparam', function(req, res) {\n\n  // VALIDATION\n  // checkBody only checks req.body; none of the other req parameters\n  // Similarly checkParams only checks in req.params (URL params) and\n  // checkQuery only checks req.query (GET params).\n  req.checkBody('postparam', 'Invalid postparam').notEmpty().isInt();\n  req.checkParams('urlparam', 'Invalid urlparam').isAlpha();\n  req.checkQuery('getparam', 'Invalid getparam').isInt();\n\n  // OR assert can be used to check on all 3 types of params.\n  // req.assert('postparam', 'Invalid postparam').notEmpty().isInt();\n  // req.assert('urlparam', 'Invalid urlparam').isAlpha();\n  // req.assert('getparam', 'Invalid getparam').isInt();\n\n  // SANITIZATION\n  // as with validation these will only validate the corresponding\n  // request object\n  req.sanitizeBody('postparam').toBoolean();\n  req.sanitizeParams('urlparam').toBoolean();\n  req.sanitizeQuery('getparam').toBoolean();\n\n  // OR find the relevent param in all areas\n  req.sanitize('postparam').toBoolean();\n\n  // Alternatively use `var result = yield req.getValidationResult();`\n  // when using generators e.g. with co-express\n  req.getValidationResult().then(function(result) {\n    if (!result.isEmpty()) {\n      res.status(400).send('There have been validation errors: ' + util.inspect(result.array()));\n      return;\n    }\n    res.json({\n      urlparam: req.params.urlparam,\n      getparam: req.params.getparam,\n      postparam: req.params.postparam\n    });\n  });\n});\n\napp.listen(8888);\n```\n\nWhich will result in:\n\n```\n$ curl -d 'postparam=1' http://localhost:8888/test?getparam=1\n{\"urlparam\":\"test\",\"getparam\":\"1\",\"postparam\":true}\n\n$ curl -d 'postparam=1' http://localhost:8888/t1est?getparam=1\nThere have been validation errors: [\n  { param: 'urlparam', msg: 'Invalid urlparam', value: 't1est' } ]\n\n$ curl -d 'postparam=1' http://localhost:8888/t1est?getparam=1ab\nThere have been validation errors: [\n  { param: 'getparam', msg: 'Invalid getparam', value: '1ab' },\n  { param: 'urlparam', msg: 'Invalid urlparam', value: 't1est' } ]\n\n$ curl http://localhost:8888/test?getparam=1&postparam=1\nThere have been validation errors: [\n  { param: 'postparam', msg: 'Invalid postparam', value: undefined} ]\n```\n\n## Middleware Options\n#### `errorFormatter`\n_function(param,msg,value)_\n\nThe `errorFormatter` option can be used to specify a function that must build the error objects used in the validation result returned by `req.getValidationResult()`.<br>\nIt should return an `Object` that has `param`, `msg`, and `value` keys defined.\n\n```javascript\n// In this example, the formParam value is going to get morphed into form body format useful for printing.\napp.use(expressValidator({\n  errorFormatter: function(param, msg, value) {\n      var namespace = param.split('.')\n      , root    = namespace.shift()\n      , formParam = root;\n\n    while(namespace.length) {\n      formParam += '[' + namespace.shift() + ']';\n    }\n    return {\n      param : formParam,\n      msg   : msg,\n      value : value\n    };\n  }\n}));\n```\n\n#### `customValidators`\n_{ \"validatorName\": function(value, [additional arguments]), ... }_\n\n\nThe `customValidators` option can be used to add additional validation methods as needed. This option should be an `Object` defining the validator names and associated validation functions.\n\nDefine your custom validators:\n\n```javascript\napp.use(expressValidator({\n customValidators: {\n    isArray: function(value) {\n        return Array.isArray(value);\n    },\n    gte: function(param, num) {\n        return param >= num;\n    }\n }\n}));\n```\nUse them with their validator name:\n```javascript\nreq.checkBody('users', 'Users must be an array').isArray();\nreq.checkQuery('time', 'Time must be an integer great than or equal to 5').isInt().gte(5)\n```\n#### `customSanitizers`\n_{ \"sanitizerName\": function(value, [additional arguments]), ... }_\n\nThe `customSanitizers` option can be used to add additional sanitizers methods as needed. This option should be an `Object` defining the sanitizer names and associated functions.\n\nDefine your custom sanitizers:\n\n```javascript\napp.use(expressValidator({\n customSanitizers: {\n    toSanitizeSomehow: function(value) {\n        var newValue = value;//some operations\n        return newValue;\n    },\n }\n}));\n```\nUse them with their sanitizer name:\n```javascript\nreq.sanitize('address').toSanitizeSomehow();\n```\n\n## Validation\n\n#### req.check();\n```javascript\n   req.check('testparam', 'Error Message').notEmpty().isInt();\n   req.check('testparam.child', 'Error Message').isInt(); // find nested params\n   req.check(['testparam', 'child'], 'Error Message').isInt(); // find nested params\n```\n\nStarts the validation of the specifed parameter, will look for the parameter in `req` in the order `params`, `query`, `body`, then validate, you can use 'dot-notation' or an array to access nested values.\n\nIf a validator takes in params, you would call it like `req.assert('reqParam').contains('thisString');`.\n\nValidators are appended and can be chained. See [chriso/validator.js](https://github.com/chriso/validator.js) for available validators, or [add your own](#customvalidators).\n\n#### req.assert();\nAlias for [req.check()](#reqcheck).\n\n#### req.validate();\nAlias for [req.check()](#reqcheck).\n\n#### req.checkBody();\nSame as [req.check()](#reqcheck), but only looks in `req.body`.\n\n#### req.checkQuery();\nSame as [req.check()](#reqcheck), but only looks in `req.query`.\n\n#### req.checkParams();\nSame as [req.check()](#reqcheck), but only looks in `req.params`.\n\n#### req.checkHeaders();\nOnly checks `req.headers`. This method is not covered by the general `req.check()`.\n\n#### req.checkCookies();\nOnly checks `req.cookies`. This method is not covered by the general `req.check()`.\n\n## Validation by Schema\n\nAlternatively you can define all your validations at once using a simple schema.\nSchema validation will be used if you pass an object to any of the validator methods.\n\nYou may pass per-validator error messages with the `errorMessage` key.\nValidator options may be passed via `options` key as an array when various values are needed,\nor as a single non-null value otherwise.\n\n```javascript\nreq.checkBody({\n 'email': {\n    optional: {\n      options: { checkFalsy: true } // or: [{ checkFalsy: true }]\n    },\n    isEmail: {\n      errorMessage: 'Invalid Email'\n    }\n  },\n  'password': {\n    notEmpty: true,\n    matches: {\n      options: ['example', 'i'] // pass options to the validator with the options property as an array\n      // options: [/example/i] // matches also accepts the full expression in the first parameter\n    },\n    errorMessage: 'Invalid Password' // Error message for the parameter\n  },\n  'name.first': { //\n    optional: true, // won't validate if field is empty\n    isLength: {\n      options: [{ min: 2, max: 10 }],\n      errorMessage: 'Must be between 2 and 10 chars long' // Error message for the validator, takes precedent over parameter message\n    },\n    errorMessage: 'Invalid First Name'\n  }\n});\n```\n\nYou can also define a specific location to validate against in the schema by adding `in` parameter as shown below:\n\n```javascript\nreq.check({\n 'email': {\n    in: 'query',\n    notEmpty: true,\n    isEmail: {\n      errorMessage: 'Invalid Email'\n    }\n  }\n});\n```\n\nPlease remember that the `in` attribute will have always highest priority. This mean if you use `in: 'query'` then checkQuery() will be called inside even if you do `checkParams()` or `checkBody()`. For example, all of these calls will check query params for email param:\n\n\n```javascript\nvar schema = {\n 'email': {\n    in: 'query',\n    notEmpty: true,\n    isEmail: {\n      errorMessage: 'Invalid Email'\n    }\n  },\n  'password': {\n    notEmpty: true,\n    matches: {\n      options: ['example', 'i'] // pass options to the validator with the options property as an array\n      // options: [/example/i] // matches also accepts the full expression in the first parameter\n    },\n    errorMessage: 'Invalid Password' // Error message for the parameter\n  }\n};\n\nreq.check(schema);        // will check 'password' no matter where it is but 'email' in query params\nreq.checkQuery(schema);   // will check 'password' and 'email' in query params\nreq.checkBody(schema);    // will check 'password' in body but 'email' in query params\nreq.checkParams(schema);  // will check 'password' in path params but 'email' in query params\nreq.checkHeaders(schema);  // will check 'password' in headers but 'email' in query params\n```\n\nCurrently supported location are `'body', 'params', 'query', 'headers'`. If you provide a location parameter that is not supported, the validation process for current parameter will be skipped.\n\n## Validation result\n\n### Result API\nThe method `req.getValidationResult()` returns a Promise which resolves to a result object.\n\n```js\nreq.assert('email', 'required').notEmpty();\nreq.assert('email', 'valid email required').isEmail();\nreq.assert('password', '6 to 20 characters required').len(6, 20);\n\nreq.getValidationResult().then(function(result) {\n  // do something with the validation result\n});\n```\n\nThe API for the result object is the following:\n\n#### `result.isEmpty()`\nReturns a boolean determining whether there were errors or not.\n\n#### `result.useFirstErrorOnly()`\nSets the `firstErrorOnly` flag of this result object, which modifies the way\nother methods like `result.array()` and `result.mapped()` work.<br>\n\nThis method is chainable, so the following is OK:\n\n```js\nresult.useFirstErrorOnly().array();\n```\n\n#### `result.array()`\nReturns an array of errors.<br>\nAll errors for all validated parameters will be included, unless you specify that you want only the first error of each param by invoking `result.useFirstErrorOnly()`.\n\n```javascript\nvar errors = result.array();\n\n// errors will now contain something like this:\n[\n  {param: \"email\", msg: \"required\", value: \"<received input>\"},\n  {param: \"email\", msg: \"valid email required\", value: \"<received input>\"},\n  {param: \"password\", msg: \"6 to 20 characters required\", value: \"<received input>\"}\n]\n```\n\n#### `result.mapped()`\nReturns an object of errors, where the key is the parameter name, and the value is an error object as returned by the error formatter.\n\nBecause of historical reasons, by default this method will return the last error of each parameter.<br>\nYou can change this behavior by invoking `result.useFirstErrorOnly()`, so the first error is returned instead.\n\n```javascript\nvar errors = result.mapped();\n\n// errors will now be similar to this:\n{\n  email: {\n    param: \"email\",\n    msg: \"valid email required\",\n    value: \"<received input>\"\n  },\n  password: {\n    param: \"password\",\n    msg: \"6 to 20 characters required\",\n    value: \"<received input>\"\n  }\n}\n```\n\n#### `result.throw()`\nIf there are errors, throws an `Error` object which is decorated with the same API as the validation result object.<br>\nUseful for dealing with the validation errors in the `catch` block of a `try..catch` or promise.\n\n```js\ntry {\n  result.throw();\n  res.send('success!');\n} catch (e) {\n  console.log(e.array());\n  res.send('oops, validation failed!');\n}\n```\n\n### Deprecated API\nThe following methods are deprecated.<br>\nWhile they work, their API is unflexible and sometimes return weird results if compared to the bleeding edge `req.getValidationResult()`.\n\nAdditionally, these methods may be removed in a future version.\n\n#### `req.validationErrors([mapped])`\nReturns synchronous errors in the form of an array, or an object that maps parameter to error in case `mapped` is passed as `true`.<br>\nIf there are no errors, the returned value is `false`.\n\n```js\nvar errors = req.validationErrors();\nif (errors) {\n  // do something with the errors\n}\n```\n\n#### `req.asyncValidationErrors([mapped])`\nReturns a promise that will either resolve if no validation errors happened, or reject with an errors array/mapping object. For reference on this, see `req.validationErrors()`.\n\n```js\nreq.asyncValidationErrors().then(function() {\n  // all good here\n}, function(errors) {\n  // damn, validation errors!\n});\n```\n\n### String formatting for error messages\n\nError messages can be customized to include both the value provided by the user, as well as the value of any parameters passed to the validation function, using a standard string replacement format:\n\n`%0` is replaced with user input\n`%1` is replaced with the first parameter to the validator\n`%2` is replaced with the second parameter to the validator\netc...\n\nExample:\n```javascript\nreq.assert('number', '%0 is not an integer').isInt();\nreq.assert('number', '%0 is not divisible by %1').isDivisibleBy(5);\n```\n\n*Note:* string replacement does **not** work with the `.withMessage()` syntax. If you'd like to have per-validator error messages with string formatting, please use the [Validation by Schema](#validation-by-schema) method instead.\n\n### Per-validation messages\n\nYou can provide an error message for a single validation with `.withMessage()`. This can be chained with the rest of your validation, and if you don't use it for one of the validations then it will fall back to the default.\n\n```javascript\nreq.assert('email', 'Invalid email')\n    .notEmpty().withMessage('Email is required')\n    .isEmail();\n\nreq.getValidationResult()\n   .then(function(result){\n     console.log(result.array());\n   });\n\n```\n\nprints:\n\n```javascript\n[\n  {param: 'email', msg: 'Email is required', value: '<received input>'}\n  {param: 'email', msg: 'Invalid Email', value: '<received input>'}\n]\n```\n\n## Optional input\n\nYou can use the `optional()` method to skip validation. By default, it only skips validation if the key does not exist on the request object. If you want to skip validation based on the property being falsy (null, undefined, etc), you can pass in `{ checkFalsy: true }`.\n\n```javascript\nreq.checkBody('email').optional().isEmail();\n//if there is no error, req.body.email is either undefined or a valid mail.\n```\n\n## Sanitizer\n\n#### req.sanitize();\n```javascript\n\nreq.body.comment = 'a <span>comment</span>';\nreq.body.username = '   a user    ';\n\nreq.sanitize('comment').escape(); // returns 'a &lt;span&gt;comment&lt;/span&gt;'\nreq.sanitize('username').trim(); // returns 'a user'\n\nconsole.log(req.body.comment); // 'a &lt;span&gt;comment&lt;/span&gt;'\nconsole.log(req.body.username); // 'a user'\n\n```\n\nSanitizes the specified parameter (using 'dot-notation' or array), the parameter will be updated to the sanitized result. Cannot be chained, and will return the result. See [chriso/validator.js](https://github.com/chriso/validator.js) for available sanitizers, or [add your own](#customsanitizers).\n\nIf a sanitizer takes in params, you would call it like `req.sanitize('reqParam').whitelist(['a', 'b', 'c']);`.\n\nIf the parameter is present in multiple places with the same name e.g. `req.params.comment` & `req.query.comment`, they will all be sanitized.\n\n#### req.filter();\nAlias for [req.sanitize()](#reqsanitize).\n\n#### req.sanitizeBody();\nSame as [req.sanitize()](#reqsanitize), but only looks in `req.body`.\n\n#### req.sanitizeQuery();\nSame as [req.sanitize()](#reqsanitize), but only looks in `req.query`.\n\n#### req.sanitizeParams();\nSame as [req.sanitize()](#reqsanitize), but only looks in `req.params`.\n\n#### req.sanitizeHeaders();\nOnly sanitizes `req.headers`. This method is not covered by the general `req.sanitize()`.\n\n#### req.sanitizeCookies();\nOnly sanitizes `req.cookies`. This method is not covered by the general `req.sanitize()`.\n\n## Regex routes\n\nExpress allows you to define regex routes like:\n\n```javascript\napp.get(/\\/test(\\d+)/, function() {});\n```\n\nYou can validate the extracted matches like this:\n\n```javascript\nreq.assert(0, 'Not a three-digit integer.').len(3, 3).isInt();\n```\n\n## TypeScript\nIf you have been using this library with [TypeScript](http://www.typescriptlang.org/),\nyou must have been using the type definitions from [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/e2af6d0/express-validator/express-validator.d.ts).\n\nHowever, as of v3.1.0, the type definitions are shipped with the library.\nSo please uninstall the typings from DT. Otherwise they may cause conflicts\n\n\n## Changelog\n\nCheck the [GitHub Releases page](https://github.com/ctavan/express-validator/releases).\n\n## License\n\nCopyright (c) 2010 Chris O'Hara <cohara87@gmail.com>, MIT License\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/ctavan/express-validator.git"
  },
  "scripts": {
    "lint": "eslint lib test",
    "report-coverage": "cat coverage/lcov.info | coveralls",
    "test": "nyc mocha && tsc",
    "travis-build": "npm test && npm run lint"
  },
  "types": "./index.d.ts",
  "version": "3.2.0"
}
